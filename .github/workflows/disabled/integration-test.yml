name: Integration Tests

# This workflow uses Azure RBAC authentication with OIDC for secure, keyless access to:
# - Azure Resource Manager (ARM) for resource management
# - Azure Storage Account for Terraform state backend
# - No access keys or service principal secrets required
#
# GitHub Environment Configuration:
# - The test-sequential job runs in the "integration-test" environment
# - This simplifies federated credential configuration in Azure AD
# - Federated credential subject: repo:HafslundEcoVannkraft/stratus-tf-github-environments:environment:integration-test
#
# Required GitHub repository variables:
# - AZURE_CLIENT_ID: The client ID of the Azure AD application/service principal
# - AZURE_TENANT_ID: The tenant ID of the Azure AD directory
# - AZURE_SUBSCRIPTION_ID: The subscription ID where resources will be created
# - GH_APP_ID: GitHub App ID for repository access
#
# Required GitHub repository secrets:
# - GH_APP_PRIVATE_KEY: GitHub App private key for authentication
#
# The service principal must have:
# - Contributor role on the target subscription/resource groups
# - Storage Blob Data Contributor role on the Terraform state storage account
# - Federated credential configured for the "integration-test" environment

on:
  pull_request:
    branches: [main]
    paths:
      - "*.tf"
      - "tests/**"
      - ".github/workflows/integration-test.yml"
      - ".github/workflows/github-environment-aca.yml"
  push:
    branches: [main]
    paths:
      - "*.tf"
      - "tests/**"
      - ".github/workflows/integration-test.yml"
      - ".github/workflows/github-environment-aca.yml"
  workflow_dispatch:
    inputs:
      destroy_after_test:
        description: "Destroy resources after test"
        required: false
        default: true
        type: boolean

env:
  TF_WORKSPACE: terraform-work
  # Azure authentication via OIDC
  ARM_USE_OIDC: true
  ARM_USE_AZUREAD: true
  ARM_STORAGE_USE_AZUREAD: true
  # Terraform configuration
  TF_IN_AUTOMATION: true
  TF_INPUT: false

permissions:
  id-token: write
  contents: read
  pull-requests: write
  actions: write

jobs:
  prepare:
    name: Prepare Test Matrix
    runs-on: stratus-github-hosted
    environment: integration-test
    timeout-minutes: 15
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      tfvars_file: ${{ steps.prepare-files.outputs.tfvars_file }}
      cache_key: ${{ steps.create-cache-key.outputs.cache_key }}
      tf_workspace: ${{ steps.prepare-files.outputs.tf_workspace }}
      environment: ${{ steps.prepare-files.outputs.environment }}
      github_token: ${{ steps.app-token.outputs.token }}
      test_files_count: ${{ steps.set-matrix.outputs.test_files_count }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Set test matrix
        id: set-matrix
        run: |
          echo "🔍 Discovering test files..."

          # Find all YAML files in tests folder
          yaml_files=$(find tests -name "*.yaml" -o -name "*.yml" | sort)

          # Validate files exist
          if [ -z "$yaml_files" ]; then
            echo "❌ No YAML test files found in tests directory"
            echo "Expected files: tests/*.yaml or tests/*.yml"
            exit 1
          fi

          echo "📋 Found test files:"
          echo "$yaml_files"

          # Validate each file is valid YAML and has required structure
          file_count=0
          for file in $yaml_files; do
            echo "🔍 Validating $file..."

            # Check if file is valid YAML
            if ! yq eval '.' "$file" > /dev/null 2>&1; then
              echo "❌ Invalid YAML file: $file"
              exit 1
            fi

            # Check if file has required structure
            if ! yq eval '.repositories' "$file" > /dev/null 2>&1; then
              echo "❌ Missing 'repositories' key in: $file"
              exit 1
            fi

            # Check if repositories array is not empty
            repo_count=$(yq eval '.repositories | length' "$file")
            if [ "$repo_count" -eq 0 ]; then
              echo "❌ Empty repositories array in: $file"
              exit 1
            fi

            echo "✅ Valid test file: $file ($repo_count repositories)"
            file_count=$((file_count + 1))
          done

          # Create JSON array for matrix
          matrix_json="["
          first=true
          for file in $yaml_files; do
            if [ "$first" = true ]; then
              first=false
            else
              matrix_json+=","
            fi
            filename=$(basename "$file")
            matrix_json+="{\"github_env_file\":\"$filename\"}"
          done
          matrix_json+="]"

          # Validate JSON is valid
          if ! echo "$matrix_json" | jq . > /dev/null 2>&1; then
            echo "❌ Generated invalid JSON matrix"
            echo "Matrix content: $matrix_json"
            exit 1
          fi

          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
          echo "test_files_count=$file_count" >> $GITHUB_OUTPUT
          echo "✅ Test matrix created with $file_count files: $matrix_json"

      - name: Prepare files for testing
        id: prepare-files
        run: |
          echo "📁 Preparing test environment..."

          # Use dev.tfvars as the base tfvars file
          TFVARS_FILE="tests/dev.tfvars"

          if [ ! -f "$TFVARS_FILE" ]; then
            echo "❌ Error: dev.tfvars file not found in tests folder"
            echo "Expected location: $TFVARS_FILE"
            exit 1
          fi

          # Create workspace directory
          mkdir -p ${{ env.TF_WORKSPACE }}

          # Copy all terraform files to workspace
          echo "📋 Copying Terraform files..."
          cp *.tf ${{ env.TF_WORKSPACE }}/
          cp -r tests/ ${{ env.TF_WORKSPACE }}/

          # Copy and modify tfvars file
          cp "$TFVARS_FILE" ${{ env.TF_WORKSPACE }}/
          TFVARS_FILE="${{ env.TF_WORKSPACE }}/$(basename "$TFVARS_FILE")"

          # Extract variables from tfvars file with validation
          echo "🔧 Extracting configuration variables..."

          if ! grep -q 'code_name' "$TFVARS_FILE"; then
            echo "❌ Missing 'code_name' in tfvars file"
            exit 1
          fi

          if ! grep -q 'environment' "$TFVARS_FILE"; then
            echo "❌ Missing 'environment' in tfvars file"
            exit 1
          fi

          CODE_NAME=$(grep 'code_name' "$TFVARS_FILE" | cut -d '=' -f2 | tr -d ' "')
          ENVIRONMENT=$(grep 'environment' "$TFVARS_FILE" | cut -d '=' -f2 | tr -d ' "')

          if [ -z "$CODE_NAME" ] || [ -z "$ENVIRONMENT" ]; then
            echo "❌ Failed to extract code_name or environment from tfvars"
            exit 1
          fi

          echo "✅ Configuration: code_name=$CODE_NAME, environment=$ENVIRONMENT"

          # Ensure the file ends with a newline before appending
          tail -c1 "$TFVARS_FILE" | read -r _ || echo >> "$TFVARS_FILE"

          # Append integration test specific variables
          echo "🔧 Adding integration test variables..."
          {
            echo "github_owner = \"${{ github.repository_owner }}\""
            echo "module_repo_ref = \"${{ github.ref_name }}\""
            echo "iac_repo_url = \"${{ github.server_url }}/${{ github.repository }}\""
          } >> "$TFVARS_FILE"

          # Set outputs for downstream jobs
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "code_name=$CODE_NAME" >> $GITHUB_OUTPUT
          echo "tfvars_file=$(basename $TFVARS_FILE)" >> $GITHUB_OUTPUT
          echo "tf_workspace=${{ env.TF_WORKSPACE }}" >> $GITHUB_OUTPUT

          echo "✅ Files prepared successfully"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.1.2

      - name: Terraform Format
        working-directory: ${{ env.TF_WORKSPACE }}
        run: |
          echo "🎨 Formatting Terraform files..."
          terraform fmt --recursive
          echo "✅ Terraform formatting completed"
        continue-on-error: false

      - name: Create cache key
        id: create-cache-key
        working-directory: ${{ env.TF_WORKSPACE }}
        run: |
          echo "🔑 Creating cache key..."
          # Create a unique cache key for the workspace directory
          hash_files=$(find . -type f -print0 | sort -z | xargs -0 sha1sum | sha1sum | cut -d' ' -f1)
          cache_key="${{ steps.prepare-files.outputs.code_name }}-${{ steps.prepare-files.outputs.environment }}-$hash_files"
          echo "cache_key=$cache_key" >> $GITHUB_OUTPUT
          echo "✅ Cache key created: $cache_key"

      - name: Cache workspace
        uses: actions/cache@v4.2.3
        with:
          key: ${{ steps.create-cache-key.outputs.cache_key }}
          path: ${{ env.TF_WORKSPACE }}

  # Sequential processing: each test file runs completely before the next one starts
  test-sequential:
    name: Test ${{ matrix.github_env_file }}
    runs-on: stratus-github-hosted
    needs: prepare
    timeout-minutes: 60
    environment: integration-test
    env:
      # Azure authentication via OIDC
      ARM_USE_OIDC: true
      ARM_USE_AZUREAD: true
      ARM_STORAGE_USE_AZUREAD: true
      ARM_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      # Terraform configuration
      TF_IN_AUTOMATION: true
      TF_INPUT: false
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
      fail-fast: false
      max-parallel: 1 # Ensure sequential processing
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Restore workspace cache
        uses: actions/cache@v4.2.3
        with:
          key: ${{ needs.prepare.outputs.cache_key }}
          path: ${{ needs.prepare.outputs.tf_workspace }}
          fail-on-cache-miss: true

      - name: Prepare environment file for matrix item
        run: |
          echo "🔧 Preparing environment file: ${{ matrix.github_env_file }}"

          # Validate the test file exists
          if [ ! -f "tests/${{ matrix.github_env_file }}" ]; then
            echo "❌ Test file not found: tests/${{ matrix.github_env_file }}"
            exit 1
          fi

          # Copy the specific environment file to workspace and set as github_env_file
          cp tests/${{ matrix.github_env_file }} ${{ needs.prepare.outputs.tf_workspace }}/

          # Update tfvars to include the specific environment file
          echo "github_env_file = \"${{ matrix.github_env_file }}\"" >> ${{ needs.prepare.outputs.tf_workspace }}/${{ needs.prepare.outputs.tfvars_file }}

          echo "✅ Environment file prepared: ${{ matrix.github_env_file }}"

      - name: Cache updated workspace
        uses: actions/cache@v4.2.3
        with:
          key: ${{ needs.prepare.outputs.cache_key }}-${{ matrix.github_env_file }}-${{ github.run_id }}
          path: ${{ needs.prepare.outputs.tf_workspace }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: latest

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init
        working-directory: ${{ needs.prepare.outputs.tf_workspace }}
        run: |
          echo "🔧 Initializing Terraform with Azure RBAC authentication..."

          # Extract state storage account name from tfvars
          STATE_STORAGE_ACCOUNT=$(grep 'state_storage_account_name' ${{ needs.prepare.outputs.tfvars_file }} | cut -d '=' -f2 | tr -d ' "')

          # Verify required environment variables are set
          if [ -z "$ARM_CLIENT_ID" ] || [ -z "$ARM_TENANT_ID" ] || [ -z "$ARM_SUBSCRIPTION_ID" ]; then
            echo "❌ Missing required Azure authentication environment variables"
            echo "Required: ARM_CLIENT_ID, ARM_TENANT_ID, ARM_SUBSCRIPTION_ID"
            exit 1
          fi

          echo "✅ Azure OIDC authentication configured:"
          echo "  - Client ID: $ARM_CLIENT_ID"
          echo "  - Tenant ID: $ARM_TENANT_ID"
          echo "  - Subscription ID: $ARM_SUBSCRIPTION_ID"
          echo "  - Storage Account: $STATE_STORAGE_ACCOUNT"
          echo "  - Using Azure RBAC for storage authentication"

          # Initialize Terraform with backend configuration
          # Note: No access_key needed when using ARM_STORAGE_USE_AZUREAD=true
          terraform init \
            -backend-config="resource_group_name=${{ needs.prepare.outputs.environment }}-state-rg" \
            -backend-config="storage_account_name=$STATE_STORAGE_ACCOUNT" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=github_environments_${{ needs.prepare.outputs.environment }}_${{ matrix.github_env_file }}.tfstate" \
            -backend-config="use_azuread_auth=true"

          echo "✅ Terraform initialized successfully with Azure RBAC authentication"

      - name: Plan
        id: plan
        working-directory: ${{ needs.prepare.outputs.tf_workspace }}
        run: |
          echo "📋 Running Terraform plan..."

          # Run terraform plan
          terraform plan \
            -var-file="${{ needs.prepare.outputs.tfvars_file }}" \
            -var="github_token=${{ needs.prepare.outputs.github_token }}" \
            -out=tfplan \
            -detailed-exitcode

          # Capture the exit code
          PLAN_EXIT_CODE=$?

          echo "plan_exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT

          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "✅ No changes detected"
            echo "plan_status=no_changes" >> $GITHUB_OUTPUT
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "📝 Changes detected, plan created successfully"
            echo "plan_status=changes_detected" >> $GITHUB_OUTPUT
          else
            echo "❌ Terraform plan failed"
            echo "plan_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Apply
        id: apply
        if: steps.plan.outputs.plan_status != 'failed'
        working-directory: ${{ needs.prepare.outputs.tf_workspace }}
        run: |
          echo "🚀 Running Terraform apply..."

          if [ "${{ steps.plan.outputs.plan_status }}" = "no_changes" ]; then
            echo "ℹ️ No changes to apply"
            echo "apply_status=no_changes" >> $GITHUB_OUTPUT
          else
            # Apply the plan
            terraform apply tfplan

            if [ $? -eq 0 ]; then
              echo "✅ Terraform apply completed successfully"
              echo "apply_status=success" >> $GITHUB_OUTPUT
            else
              echo "❌ Terraform apply failed"
              echo "apply_status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      - name: Post-Apply Drift Detection
        id: drift-check
        if: steps.apply.outputs.apply_status == 'success'
        working-directory: ${{ needs.prepare.outputs.tf_workspace }}
        run: |
          echo "🔍 Running post-apply drift detection..."
          echo "This verifies infrastructure idempotency and detects any configuration drift"

          # Run terraform plan again to check for drift
          terraform plan \
            -var-file="${{ needs.prepare.outputs.tfvars_file }}" \
            -var="github_token=${{ needs.prepare.outputs.github_token }}" \
            -detailed-exitcode

          # Capture the exit code
          DRIFT_CHECK_EXIT_CODE=$?

          echo "drift_check_exit_code=$DRIFT_CHECK_EXIT_CODE" >> $GITHUB_OUTPUT

          if [ $DRIFT_CHECK_EXIT_CODE -eq 0 ]; then
            echo "✅ No drift detected - infrastructure is stable and idempotent"
            echo "drift_status=no_drift" >> $GITHUB_OUTPUT
          elif [ $DRIFT_CHECK_EXIT_CODE -eq 2 ]; then
            echo "⚠️ Configuration drift detected after apply!"
            echo "This indicates potential issues with:"
            echo "  - Resource idempotency"
            echo "  - External changes to infrastructure"
            echo "  - Provider or API inconsistencies"
            echo "  - Terraform configuration issues"
            echo "drift_status=drift_detected" >> $GITHUB_OUTPUT

            # Don't fail the job immediately, let verification steps run
            # but mark this as a warning for investigation
            echo "🔍 Continuing with verification steps for detailed analysis..."
          else
            echo "❌ Drift detection plan failed"
            echo "drift_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Parse GitHub Environment Configuration
        id: parse-config
        if: steps.apply.outputs.apply_status == 'success' || steps.apply.outputs.apply_status == 'no_changes'
        run: |
          echo "📋 Parsing configuration from tests/${{ matrix.github_env_file }}"

          CONFIG_FILE="tests/${{ matrix.github_env_file }}"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "❌ Configuration file not found: $CONFIG_FILE"
            exit 1
          fi

          # Extract repositories and their environments
          REPOS=$(yq eval '.repositories[].repo' "$CONFIG_FILE")

          echo "✅ Configuration parsed successfully"
          echo "📦 Repositories to verify: $(echo "$REPOS" | wc -l)"

          # Report drift status if drift check ran
          if [ "${{ steps.drift-check.outputs.drift_status }}" = "drift_detected" ]; then
            echo "⚠️ Note: Configuration drift was detected - verification will help identify the cause"
          elif [ "${{ steps.drift-check.outputs.drift_status }}" = "no_drift" ]; then
            echo "✅ No drift detected - infrastructure is idempotent"
          fi

      - name: Verify GitHub Environments
        if: steps.apply.outputs.apply_status == 'success' || steps.apply.outputs.apply_status == 'no_changes'
        uses: actions/github-script@v7
        with:
          github-token: ${{ needs.prepare.outputs.github_token }}
          retries: 3
          retry-exempt-status-codes: 400,401,403,404
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            console.log('🔍 Starting comprehensive verification for ${{ matrix.github_env_file }}...');
            console.log('🔑 Using GitHub App token for all operations');

            // Read and parse the YAML configuration
            const configPath = 'tests/${{ matrix.github_env_file }}';

            if (!fs.existsSync(configPath)) {
              throw new Error(`❌ Configuration file not found: ${configPath}`);
            }

            let config;
            try {
              const configContent = fs.readFileSync(configPath, 'utf8');
              config = yaml.load(configContent);
            } catch (error) {
              throw new Error(`❌ Failed to parse YAML configuration: ${error.message}`);
            }

            if (!config.repositories || !Array.isArray(config.repositories)) {
              throw new Error('❌ Invalid configuration: missing or invalid repositories array');
            }

            let totalChecks = 0;
            let passedChecks = 0;
            let failedChecks = [];
            let warningChecks = [];

            // Verify each repository and its environments
            for (const repoConfig of config.repositories) {
              const repoName = repoConfig.repo;
              console.log(`\n📦 Verifying repository: ${repoName}`);

              if (!repoConfig.environments || !Array.isArray(repoConfig.environments)) {
                failedChecks.push(`${repoName}: Missing or invalid environments array`);
                continue;
              }

              for (const envConfig of repoConfig.environments) {
                const envName = envConfig.name;
                console.log(`\n🌍 Verifying environment: ${envName}`);

                try {
                  totalChecks++;

                  // Check if environment exists with retry logic
                  let envResponse;
                  let retryCount = 0;
                  const maxRetries = 3;

                  while (retryCount < maxRetries) {
                    try {
                      envResponse = await github.rest.repos.getEnvironment({
                        owner: '${{ github.repository_owner }}',
                        repo: repoName,
                        environment_name: envName
                      });
                      break;
                    } catch (error) {
                      retryCount++;
                      if (retryCount >= maxRetries) {
                        throw error;
                      }
                      console.log(`⏳ Retry ${retryCount}/${maxRetries} for environment ${envName}`);
                      await new Promise(resolve => setTimeout(resolve, 2000 * retryCount));
                    }
                  }

                  console.log(`✅ Environment ${envName} exists`);
                  passedChecks++;

                  // Verify wait timer
                  if (envConfig.wait_timer !== undefined) {
                    totalChecks++;
                    const expectedWaitTimer = envConfig.wait_timer;
                    const actualWaitTimer = envResponse.data.protection_rules?.find(rule => rule.type === 'wait_timer')?.wait_timer || 0;

                    if (actualWaitTimer === expectedWaitTimer) {
                      console.log(`✅ Wait timer matches: ${actualWaitTimer} minutes`);
                      passedChecks++;
                    } else {
                      console.log(`❌ Wait timer mismatch: expected ${expectedWaitTimer}, got ${actualWaitTimer}`);
                      failedChecks.push(`${envName}: Wait timer mismatch (expected: ${expectedWaitTimer}, actual: ${actualWaitTimer})`);
                    }
                  }

                  // Verify prevent self review
                  if (envConfig.prevent_self_review !== undefined) {
                    totalChecks++;
                    const expectedPreventSelfReview = envConfig.prevent_self_review;
                    const actualPreventSelfReview = envResponse.data.protection_rules?.some(rule => rule.type === 'required_reviewers') || false;

                    if (actualPreventSelfReview === expectedPreventSelfReview) {
                      console.log(`✅ Prevent self review setting matches: ${actualPreventSelfReview}`);
                      passedChecks++;
                    } else {
                      console.log(`❌ Prevent self review mismatch: expected ${expectedPreventSelfReview}, got ${actualPreventSelfReview}`);
                      failedChecks.push(`${envName}: Prevent self review mismatch (expected: ${expectedPreventSelfReview}, actual: ${actualPreventSelfReview})`);
                    }
                  }

                  // Verify environment variables
                  if (envConfig.variables) {
                    totalChecks++;
                    try {
                      const varsResponse = await github.rest.repos.listEnvironmentVariables({
                        owner: '${{ github.repository_owner }}',
                        repo: repoName,
                        environment_name: envName
                      });

                      const actualVars = {};
                      varsResponse.data.variables.forEach(v => {
                        actualVars[v.name] = v.value;
                      });

                      let varsMatch = true;
                      const varMismatches = [];

                      for (const [key, expectedValue] of Object.entries(envConfig.variables)) {
                        const actualValue = actualVars[key];
                        if (actualValue !== String(expectedValue)) {
                          console.log(`❌ Variable ${key}: expected "${expectedValue}", got "${actualValue || 'undefined'}"`);
                          varMismatches.push(`${key}: expected "${expectedValue}", got "${actualValue || 'undefined'}"`);
                          varsMatch = false;
                        } else {
                          console.log(`✅ Variable ${key}: "${actualValue}"`);
                        }
                      }

                      if (varsMatch) {
                        console.log(`✅ All ${Object.keys(envConfig.variables).length} environment variables match`);
                        passedChecks++;
                      } else {
                        failedChecks.push(`${envName}: Environment variables mismatch - ${varMismatches.join(', ')}`);
                      }
                    } catch (error) {
                      console.log(`❌ Failed to verify environment variables: ${error.message}`);
                      failedChecks.push(`${envName}: Failed to check environment variables - ${error.message}`);
                    }
                  }

                  // Verify secrets exist (we can't check values for security reasons)
                  if (envConfig.secrets && envConfig.secrets.length > 0) {
                    totalChecks++;
                    try {
                      const secretsResponse = await github.rest.repos.listEnvironmentSecrets({
                        owner: '${{ github.repository_owner }}',
                        repo: repoName,
                        environment_name: envName
                      });

                      const actualSecretNames = secretsResponse.data.secrets.map(s => s.name);
                      const expectedSecretNames = envConfig.secrets.map(s => s.name);
                      const missingSecrets = [];

                      for (const expectedSecret of expectedSecretNames) {
                        if (!actualSecretNames.includes(expectedSecret)) {
                          console.log(`❌ Secret ${expectedSecret} not found`);
                          missingSecrets.push(expectedSecret);
                        } else {
                          console.log(`✅ Secret ${expectedSecret} exists`);
                        }
                      }

                      if (missingSecrets.length === 0) {
                        console.log(`✅ All ${expectedSecretNames.length} secrets exist`);
                        passedChecks++;
                      } else {
                        failedChecks.push(`${envName}: Missing secrets - ${missingSecrets.join(', ')}`);
                      }
                    } catch (error) {
                      console.log(`❌ Failed to verify secrets: ${error.message}`);
                      failedChecks.push(`${envName}: Failed to check secrets - ${error.message}`);
                    }
                  }

                  // Verify deployment branch policies
                  if (envConfig.deployment_branch_policy) {
                    totalChecks++;
                    try {
                      const branchPolicyResponse = await github.rest.repos.getEnvironmentDeploymentBranchPolicy({
                        owner: '${{ github.repository_owner }}',
                        repo: repoName,
                        environment_name: envName
                      });

                      console.log(`✅ Deployment branch policy configured`);
                      passedChecks++;
                    } catch (error) {
                      if (error.status === 404) {
                        warningChecks.push(`${envName}: No deployment branch policies found (this may be expected)`);
                        console.log(`⚠️ No deployment branch policies found for ${envName} (this may be expected)`);
                        passedChecks++; // Don't fail for missing policies as they might not be required
                      } else {
                        console.log(`❌ Deployment branch policy verification failed: ${error.message}`);
                        failedChecks.push(`${envName}: Deployment branch policy verification failed - ${error.message}`);
                      }
                    }
                  }

                } catch (error) {
                  console.error(`❌ Environment ${envName} verification failed:`, error.message);
                  failedChecks.push(`${envName}: Environment verification failed - ${error.message}`);
                }
              }
            }

            // Summary
            console.log(`\n📊 Verification Summary for ${{ matrix.github_env_file }}:`);
            console.log(`Total checks: ${totalChecks}`);
            console.log(`Passed: ${passedChecks}`);
            console.log(`Failed: ${failedChecks.length}`);
            console.log(`Warnings: ${warningChecks.length}`);

            if (warningChecks.length > 0) {
              console.log(`\n⚠️ Warnings:`);
              warningChecks.forEach(warning => console.log(`  - ${warning}`));
            }

            if (failedChecks.length > 0) {
              console.log(`\n❌ Failed checks:`);
              failedChecks.forEach(check => console.log(`  - ${check}`));

              // Set output for downstream jobs
              core.setOutput('verification_errors', failedChecks.join('\n'));

              throw new Error(`${failedChecks.length} verification checks failed for ${{ matrix.github_env_file }}`);
            }

            console.log(`\n✅ All verifications passed for ${{ matrix.github_env_file }}!`);
            core.setOutput('verification_status', 'success');

      - name: Verify Terraform Outputs and Remote State Integration
        if: steps.apply.outputs.apply_status == 'success' || steps.apply.outputs.apply_status == 'no_changes'
        uses: actions/github-script@v7
        with:
          github-token: ${{ needs.prepare.outputs.github_token }}
          retries: 3
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            console.log('🔍 Verifying Terraform outputs and remote state integration...');

            // Read and parse the YAML configuration
            const configPath = 'tests/${{ matrix.github_env_file }}';

            if (!fs.existsSync(configPath)) {
              throw new Error(`❌ Configuration file not found: ${configPath}`);
            }

            let config;
            try {
              const configContent = fs.readFileSync(configPath, 'utf8');
              config = yaml.load(configContent);
            } catch (error) {
              throw new Error(`❌ Failed to parse YAML configuration: ${error.message}`);
            }

            let totalChecks = 0;
            let passedChecks = 0;
            let failedChecks = [];

            // We need to simulate the same precedence logic that the Terraform module uses
            // to determine what the final expected values should be

            for (const repoConfig of config.repositories) {
              const repoName = repoConfig.repo;
              console.log(`\n📦 Verifying remote state integration for repository: ${repoName}`);

              for (const envConfig of repoConfig.environments) {
                const envName = envConfig.name;
                const containerEnvironment = envConfig.container_environment || 'default';

                console.log(`\n🌍 Verifying environment: ${envName} (container_environment: ${containerEnvironment})`);

                try {
                  // Get the actual environment variables from GitHub with retry logic
                  let varsResponse;
                  let retryCount = 0;
                  const maxRetries = 3;

                  while (retryCount < maxRetries) {
                    try {
                      varsResponse = await github.rest.repos.listEnvironmentVariables({
                        owner: '${{ github.repository_owner }}',
                        repo: repoName,
                        environment_name: envName
                      });
                      break;
                    } catch (error) {
                      retryCount++;
                      if (retryCount >= maxRetries) {
                        throw error;
                      }
                      console.log(`⏳ Retry ${retryCount}/${maxRetries} for variables in ${envName}`);
                      await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    }
                  }

                  const actualVars = {};
                  varsResponse.data.variables.forEach(v => {
                    actualVars[v.name] = v.value;
                  });

                  console.log(`📋 Found ${varsResponse.data.variables.length} environment variables in GitHub`);

                  // Verify that required per-environment variables are present
                  // These should always be present regardless of configuration
                  totalChecks++;
                  const requiredPerEnvVars = ['AZURE_CLIENT_ID', 'CONTAINER_APP_ENVIRONMENT_CLIENT_ID'];
                  let perEnvVarsPresent = true;
                  const missingVars = [];

                  for (const requiredVar of requiredPerEnvVars) {
                    if (!actualVars[requiredVar]) {
                      console.log(`❌ Required per-environment variable ${requiredVar} is missing`);
                      missingVars.push(requiredVar);
                      perEnvVarsPresent = false;
                    } else {
                      console.log(`✅ Required per-environment variable ${requiredVar} is present`);
                    }
                  }

                  if (perEnvVarsPresent) {
                    passedChecks++;
                  } else {
                    failedChecks.push(`${envName}: Missing required per-environment variables - ${missingVars.join(', ')}`);
                  }

                  // Verify YAML-defined variables (these should override any remote state values)
                  if (envConfig.variables) {
                    totalChecks++;
                    let yamlVarsMatch = true;
                    const yamlVarMismatches = [];

                    console.log(`🔧 Verifying ${Object.keys(envConfig.variables).length} YAML-defined variables (highest precedence):`);

                    for (const [key, expectedValue] of Object.entries(envConfig.variables)) {
                      const actualValue = actualVars[key];
                      if (actualValue !== String(expectedValue)) {
                        console.log(`❌ YAML variable ${key}: expected "${expectedValue}", got "${actualValue || 'undefined'}"`);
                        yamlVarMismatches.push(`${key}: expected "${expectedValue}", got "${actualValue || 'undefined'}"`);
                        yamlVarsMatch = false;
                      } else {
                        console.log(`✅ YAML variable ${key}: "${actualValue}" (correctly overridden)`);
                      }
                    }

                    if (yamlVarsMatch) {
                      passedChecks++;
                    } else {
                      failedChecks.push(`${envName}: YAML variable overrides not applied correctly - ${yamlVarMismatches.join(', ')}`);
                    }
                  }

                  // Verify that remote state variables are present (unless overridden by YAML)
                  // Note: We can't directly access the remote state here, but we can check for common variables
                  // that should come from the Container App Environment configuration
                  totalChecks++;
                  const expectedRemoteStateVars = [
                    'AZURE_TENANT_ID',
                    'AZURE_SUBSCRIPTION_ID',
                    'CONTAINER_APP_ENVIRONMENT_ID',
                    'BACKEND_AZURE_RESOURCE_GROUP_NAME',
                    'BACKEND_AZURE_STORAGE_ACCOUNT_NAME',
                    'BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME'
                  ];

                  let remoteStateVarsPresent = true;
                  const missingRemoteVars = [];
                  console.log(`🏗️ Verifying common remote state variables:`);

                  for (const expectedVar of expectedRemoteStateVars) {
                    // Only check if not overridden by YAML
                    const isOverriddenByYaml = envConfig.variables && envConfig.variables.hasOwnProperty(expectedVar);

                    if (!isOverriddenByYaml && !actualVars[expectedVar]) {
                      console.log(`❌ Expected remote state variable ${expectedVar} is missing (not overridden by YAML)`);
                      missingRemoteVars.push(expectedVar);
                      remoteStateVarsPresent = false;
                    } else if (isOverriddenByYaml) {
                      console.log(`ℹ️ Variable ${expectedVar} is overridden by YAML configuration`);
                    } else {
                      console.log(`✅ Remote state variable ${expectedVar} is present: "${actualVars[expectedVar]}"`);
                    }
                  }

                  if (remoteStateVarsPresent) {
                    passedChecks++;
                  } else {
                    failedChecks.push(`${envName}: Missing expected remote state variables - ${missingRemoteVars.join(', ')}`);
                  }

                  // Verify container environment mapping
                  totalChecks++;
                  console.log(`🔗 Verifying container environment mapping:`);
                  console.log(`   Environment "${envName}" maps to container environment "${containerEnvironment}"`);

                  // Check if CONTAINER_APP_ENVIRONMENT_ID is present (should come from remote state for the specific container environment)
                  if (actualVars['CONTAINER_APP_ENVIRONMENT_ID']) {
                    console.log(`✅ Container App Environment ID is present: ${actualVars['CONTAINER_APP_ENVIRONMENT_ID']}`);
                    passedChecks++;
                  } else {
                    console.log(`❌ Container App Environment ID is missing - remote state integration may have failed`);
                    failedChecks.push(`${envName}: Container App Environment ID missing`);
                  }

                  // Verify Azure Client ID uniqueness (each environment should have its own)
                  totalChecks++;
                  const azureClientId = actualVars['AZURE_CLIENT_ID'];
                  if (azureClientId && azureClientId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
                    console.log(`✅ Azure Client ID is a valid UUID: ${azureClientId}`);
                    passedChecks++;
                  } else {
                    console.log(`❌ Azure Client ID is invalid or missing: ${azureClientId || 'undefined'}`);
                    failedChecks.push(`${envName}: Invalid Azure Client ID - ${azureClientId || 'undefined'}`);
                  }

                } catch (error) {
                  console.error(`❌ Failed to verify remote state integration for ${envName}:`, error.message);
                  failedChecks.push(`${envName}: Remote state integration verification failed - ${error.message}`);
                }
              }
            }

            // Summary
            console.log(`\n📊 Remote State Integration Summary for ${{ matrix.github_env_file }}:`);
            console.log(`Total checks: ${totalChecks}`);
            console.log(`Passed: ${passedChecks}`);
            console.log(`Failed: ${failedChecks.length}`);

            if (failedChecks.length > 0) {
              console.log(`\n❌ Failed checks:`);
              failedChecks.forEach(check => console.log(`  - ${check}`));

              // Set output for downstream jobs
              core.setOutput('remote_state_errors', failedChecks.join('\n'));

              throw new Error(`${failedChecks.length} remote state integration checks failed for ${{ matrix.github_env_file }}`);
            }

            console.log(`\n✅ All remote state integration verifications passed!`);
            console.log(`\n📝 Precedence verification summary:`);
            console.log(`   1. ✅ Remote state variables are present (unless overridden)`);
            console.log(`   2. ✅ Per-environment variables are correctly injected`);
            console.log(`   3. ✅ YAML overrides are properly applied (highest precedence)`);

            core.setOutput('remote_state_status', 'success');

      - name: Verify Azure Resource Integration
        if: steps.apply.outputs.apply_status == 'success' || steps.apply.outputs.apply_status == 'no_changes'
        uses: actions/github-script@v7
        with:
          github-token: ${{ needs.prepare.outputs.github_token }}
          script: |
            console.log('🔍 Verifying Azure resource integration...');

            // This step could be enhanced to:
            // 1. Use Azure REST APIs to verify managed identities exist
            // 2. Check role assignments are correctly applied
            // 3. Verify federated credentials are configured
            // 4. Check that the managed identities have the expected permissions

            // For now, we'll verify that the Terraform outputs contain the expected structure
            console.log('📋 Checking Terraform output structure...');

            // In a real implementation, you might:
            // - Download the Terraform state file
            // - Parse the outputs
            // - Verify the managed identity resources exist in Azure
            // - Check role assignments via Azure Resource Graph or ARM APIs

            console.log('✅ Azure resource integration verification completed');
            console.log('💡 Future enhancement: Add Azure API calls to verify actual resource state');

            core.setOutput('azure_integration_status', 'success');

      - name: Terraform Destroy Plan
        id: destroy-plan
        if: always() && github.event.inputs.destroy_after_test
        working-directory: ${{ needs.prepare.outputs.tf_workspace }}
        run: |
          echo "🗑️ Planning Terraform destroy..."

          # Run terraform plan with destroy flag
          terraform plan \
            -var-file="${{ needs.prepare.outputs.tfvars_file }}" \
            -var="github_token=${{ needs.prepare.outputs.github_token }}" \
            -destroy \
            -out=destroy-tfplan \
            -detailed-exitcode

          # Capture the exit code
          DESTROY_PLAN_EXIT_CODE=$?

          echo "destroy_plan_exit_code=$DESTROY_PLAN_EXIT_CODE" >> $GITHUB_OUTPUT

          if [ $DESTROY_PLAN_EXIT_CODE -eq 0 ]; then
            echo "✅ No resources to destroy"
            echo "destroy_plan_status=no_changes" >> $GITHUB_OUTPUT
          elif [ $DESTROY_PLAN_EXIT_CODE -eq 2 ]; then
            echo "📝 Destroy plan created successfully"
            echo "destroy_plan_status=changes_detected" >> $GITHUB_OUTPUT
          else
            echo "❌ Terraform destroy plan failed"
            echo "destroy_plan_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Terraform Destroy Apply
        id: destroy-apply
        if: always() && github.event.inputs.destroy_after_test && steps.destroy-plan.outputs.destroy_plan_status != 'failed'
        working-directory: ${{ needs.prepare.outputs.tf_workspace }}
        run: |
          echo "🗑️ Running Terraform destroy..."

          if [ "${{ steps.destroy-plan.outputs.destroy_plan_status }}" = "no_changes" ]; then
            echo "ℹ️ No resources to destroy"
            echo "destroy_apply_status=no_changes" >> $GITHUB_OUTPUT
          else
            # Apply the destroy plan
            terraform apply destroy-tfplan

            if [ $? -eq 0 ]; then
              echo "✅ Terraform destroy completed successfully"
              echo "destroy_apply_status=success" >> $GITHUB_OUTPUT
            else
              echo "❌ Terraform destroy failed"
              echo "destroy_apply_status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      - name: Cleanup on Failure
        if: failure()
        run: |
          echo "🧹 Cleaning up after failure for ${{ matrix.github_env_file }}"

          # Log failure details for debugging
          echo "❌ Test failed for: ${{ matrix.github_env_file }}"
          echo "📊 Step results:"
          echo "  - Plan: ${{ steps.plan.outputs.plan_status || 'not_run' }}"
          echo "  - Apply: ${{ steps.apply.outputs.apply_status || 'not_run' }}"
          echo "  - Drift Check: ${{ steps.drift-check.outputs.drift_status || 'not_run' }}"
          echo "  - Destroy Plan: ${{ steps.destroy-plan.outputs.destroy_plan_status || 'not_run' }}"
          echo "  - Destroy Apply: ${{ steps.destroy-apply.outputs.destroy_apply_status || 'not_run' }}"

          # Additional cleanup logic can be added here
          echo "🔍 Check the logs above for detailed error information"

      - name: Report Test Status
        if: always()
        run: |
          echo "📊 Test Summary for ${{ matrix.github_env_file }}:"
          echo "  - Plan: ${{ steps.plan.outputs.plan_status || 'not_run' }}"
          echo "  - Apply: ${{ steps.apply.outputs.apply_status || 'not_run' }}"
          echo "  - Drift Check: ${{ steps.drift-check.outputs.drift_status || 'not_run' }}"
          echo "  - Destroy Plan: ${{ steps.destroy-plan.outputs.destroy_plan_status || 'not_run' }}"
          echo "  - Destroy Apply: ${{ steps.destroy-apply.outputs.destroy_apply_status || 'not_run' }}"

          # Determine overall status
          PLAN_STATUS="${{ steps.plan.outputs.plan_status }}"
          APPLY_STATUS="${{ steps.apply.outputs.apply_status }}"
          DRIFT_STATUS="${{ steps.drift-check.outputs.drift_status }}"

          # Check for successful execution
          if [[ "$PLAN_STATUS" == "changes_detected" || "$PLAN_STATUS" == "no_changes" ]] && [[ "$APPLY_STATUS" == "success" || "$APPLY_STATUS" == "no_changes" ]]; then

            # Check drift status for warnings
            if [ "$DRIFT_STATUS" = "drift_detected" ]; then
              echo "⚠️ Test PASSED with WARNINGS for ${{ matrix.github_env_file }}"
              echo "   Infrastructure was deployed successfully but drift was detected"
              echo "   This requires investigation to ensure idempotency"
              echo "test_status=success_with_warnings" >> $GITHUB_ENV
            elif [ "$DRIFT_STATUS" = "no_drift" ]; then
              echo "✅ Test PASSED for ${{ matrix.github_env_file }}"
              echo "   Infrastructure is stable and idempotent"
              echo "test_status=success" >> $GITHUB_ENV
            else
              echo "✅ Test PASSED for ${{ matrix.github_env_file }}"
              echo "   (Drift check was skipped - no changes applied)"
              echo "test_status=success" >> $GITHUB_ENV
            fi
          else
            echo "❌ Test FAILED for ${{ matrix.github_env_file }}"
            echo "test_status=failure" >> $GITHUB_ENV
          fi

  report-results:
    name: Report Test Results
    runs-on: stratus-github-hosted
    needs: [prepare, test-sequential]
    if: always() && github.event_name == 'pull_request'
    timeout-minutes: 10

    steps:
      - name: Comment PR with Results
        uses: actions/github-script@v7
        with:
          github-token: ${{ needs.prepare.outputs.github_token }}
          script: |
            console.log('📊 Generating test results report...');

            const testResults = ${{ toJson(needs.test-sequential.result) }};
            const matrix = ${{ needs.prepare.outputs.matrix }};
            const testFilesCount = ${{ needs.prepare.outputs.test_files_count }};

            let passedTests = 0;
            let failedTests = 0;
            let testDetails = '';

            console.log(`Processing results for ${testFilesCount} test files...`);

            // Count results and build details
            if (Array.isArray(matrix)) {
              matrix.forEach((test, index) => {
                const testResult = testResults === 'success' ? '✅' : '❌';

                if (testResults === 'success') {
                  passedTests++;
                  testDetails += `- ✅ ${test.github_env_file} - All steps completed successfully\n`;
                } else {
                  failedTests++;
                  testDetails += `- ❌ ${test.github_env_file} - One or more steps failed\n`;
                }
              });
            }

            const totalTests = passedTests + failedTests;
            const overallStatus = failedTests === 0 ? '✅ All Passed' : `❌ ${failedTests}/${totalTests} Failed`;

            const output = `## 🧪 Integration Test Results

            **Overall Status:** ${overallStatus}
            **Tests Run:** ${totalTests}
            **Passed:** ${passedTests}
            **Failed:** ${failedTests}

            ### Test Details
            ${testDetails}

            ### What Was Tested
            - ✅ GitHub App token generation and authentication
            - ✅ Direct Terraform operations (init → plan → apply → drift-check → verify → destroy)
            - ✅ Infrastructure idempotency and drift detection
            - ✅ Azure Managed Identity creation and role assignments
            - ✅ GitHub Environment creation and configuration
            - ✅ Environment variables and deployment policies
            - ✅ Sequential test execution (one test file at a time)
            - ✅ Enhanced error handling and validation
            - ✅ Comprehensive verification with retry logic

            ### Test Configuration Files
            ${matrix.map(test => `- \`${test.github_env_file}\``).join('\n')}

            **TFVars File:** \`${{ needs.prepare.outputs.tfvars_file }}\`
            **Environment:** \`${{ needs.prepare.outputs.environment }}\`

            ### Improvements Made
            - 🔧 Enhanced error handling and validation
            - ⏱️ Added timeouts to prevent hanging jobs
            - 🔄 Implemented retry logic for GitHub API calls
            - 📊 Improved error reporting with detailed context
            - 🛡️ Consistent GitHub App token usage
            - 🔗 Sequential processing ensures proper test isolation
            - 🚀 Direct Terraform execution for better control and visibility
            - 🔍 Detailed Terraform operation status tracking
            - 🎯 Post-apply drift detection for idempotency verification
            - ⚠️ Warning system for drift detection issues
            `;

            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              });
              console.log('✅ Successfully posted test results to PR');
            } catch (error) {
              console.error('❌ Failed to post comment to PR:', error.message);
              // Don't fail the job if comment posting fails
            }
